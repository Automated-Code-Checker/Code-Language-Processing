Code,Marks
"['int main()', '{', 'int K=4, columns=4;', 'typedef D {int G[4][4],M[2][2]}pooling;', 'int I[2][2]={0,0,', '   0,0};', 'int L[2][2],F,A;', 'H  B,C,*p,*q;', 'p=&a;', 'for(i=0;F<4;F++)', '{', 'for(j=0;A<4;A++)', '{', 'printf(""enter G values [%d][%d] "",F,A);', 'scanf(""%d"",&p->matrix[F][A]);', '}', 'printf(""\\n"");', '}', 'J=&b;', 'for(i=0;F<2;F++)', '{', 'for(j=0;A<2;A++)', '{', 'if(p->matrix[F][A]>=I[0][0])', '{', 'I[0][0]=p->matrix[F][A];', '}', '}', '}', 'printf(""\\nmax[0][0] is %d"",I[0][0]);', 'for(i=0;F<2;F++)', '{', 'for(j=2;A<4;A++)', '{', 'if(p->matrix[F][A]>=I[0][1])', 'I[0][1]=p->matrix[F][A];', '}', '}', 'printf(""\\nmax[0][1] is %d"",I[0][1]);', 'for(i=2;F<4;F++)', '{', 'for(j=0;A<2;A++)', '{', 'if(p->matrix[F][A]>=I[1][0])', 'I[1][0]=p->matrix[F][A];', '}', '}', 'printf(""\\nmax[1][0] is %d"",I[1][0]);', 'for(i=2;F<4;F++)', '{', 'for(j=2;A<4;A++)', '{', 'if(p->matrix[F][A]>=I[1][1])', 'I[1][1]=p->matrix[F][A];', '}', '}', 'printf(""\\nmax[1][1] is %d"",I[1][1]);', 'printf(""\\n\\npooled matrix\\n"");', 'for(i=0;F<2;F++)', '{', 'for(j=0;A<2;A++)', '{', 'J->pooled[F][A]=I[F][A];', '}', '}', 'printf(""\\n"");', 'for(i=0;F<2;F++)', '{', 'for(j=0;A<2;A++)', '{', 'printf(""%d "",J->pooled[F][A]);', '}', 'printf(""\\n"");', '}', 'return 0;', '}']",2
"['struct A', '{', ' int Z;', ' int K;', ' ', '};', ' ', ' ', ' int main()', ' {', ' ', 'int E[100][100],F[100][100],R[100][100],W[100][100],T,M[100][100],M1=0,L=0,M3=0,M4=0;', ' ', 'int H, B;', ' ', ' ', 'struct A G;', ' ', ' ', 'printf(""enter S A a S V Z Y columns (both I be N)\\n"");', ' ', 'scanf(""%d"",&s.Z);', ' ', 'scanf(""%d"",&s.K);', ' ', ' ', ' ', 'printf(""enter S elements a S D matrix\\n"");', ' ', ' ', 'for (i=0;H<s.Z;H++)', ' ', '{', ' ', 'for (j=0; B<s.K; B++)', ' ', '{', ' ', 'scanf(""%d"",&a[H][ B]);', ' ', 'if(a[H][ B]>m1)', ' ', '{', ' ', 'M1 =E[H][ B];', ' ', 'M[H][ B]= M1;', ' }', ' ', '    }', '}', '    printf(""enter S elements a S P matrix\\n"");', ' ', ' ', 'for (i=0;H<s.Z;H++)', ' ', '{', ' ', 'for (j=0; B<s.K; B++)', ' ', '{', ' ', 'scanf(""%d"",&b[H][ B]);', ' ', 'if(b[H][ B]>m2)', ' ', '{', ' ', 'L =F[H][ B];', ' ', 'M[H][ B]= L;', ' }', ' ', '    }', '}', '    ', '    printf(""enter S elements a S Q J \\n"");', ' ', ' ', 'for (i=0;H<s.Z;H++)', ' ', '{', ' ', 'for (j=0; B<s.K; B++)', ' ', '{', ' ', 'scanf(""%d"",&c[H][ B]);', ' ', 'if(c[H][ B]>m3)', ' ', '{', ' ', 'M3 =R[H][ B];', ' ', 'M[H][ B]= M3;', ' }', ' ', '    }', '}', '    printf(""enter S elements a S C matrix\\n"");', ' ', ' ', 'for (i=0;H<s.Z;H++)', ' ', '{', ' ', 'for (j=0; B<s.K; B++)', ' ', '{', ' ', 'scanf(""%d"",&d[H][ B]);', ' ', 'if(d[H][ B]>m4)', ' ', '{', ' ', 'M4 =W[H][ B];', ' ', 'M[H][ B]= M4;', ' }', ' ', '    }', ' ', '}', 'printf(""joined J numbers\\n"");', 'for(i=0;H<2;H++)', '{', 'for(j=0; B<2; B++)', '{', 'printf(""%d"",E[H][ B]);', 'printf(""%d"",F[H][ B]);', '}', 'printf(""\\n"");', '}', 'for(i=0;H<2;H++)', '{', 'for(j=0; B<2; B++)', '{', 'printf(""%d"",R[H][ B]);', 'printf(""%d"",W[H][ B]);', '}', 'printf(""\\n"");', '}', 'printf(""\\nfiltered J numbers\\n"");', 'for(i=0;H<2;H++)', '{', 'for(j=0; B<2; B++)', '{', 'printf(""%d"",M[H][ B]);', '}', 'printf(""\\n"");', '}', ' }']",1.2
"['struct G', '{', 'int Q;', 'int N;', 'int C[4][4];', '};', 'void main()', '{', 'struct G *ptr, D;', 'int F,  B, resarr[2][2], J, O, I, A;', 'ptr=&mat;', 'printf(""Enter L of E:"");', 'scanf(""%d"", &ptr->row);', 'printf(""\\nEnter L of N:"");', 'scanf(""%d"", &ptr->col);', 'for(i=0; F<(ptr->row); ++i)', '{', 'for(j=0;  B<(ptr->col); ++j)', '{', 'printf(""Enter M of P %drow, %d col"", F,  B);', 'scanf(""%d"", &ptr->arr1[F][ B]);', '}', '}', 'J=ptr->arr1[0][0];', 'if(h1<ptr->arr1[0][1])', '{', 'J=ptr->arr1[0][1];', '}', 'if(h1<ptr->arr1[1][0])', '{', 'J=ptr->arr1[1][0];', '}', 'if(h1<ptr->arr1[1][1])', '{', 'J=ptr->arr1[1][1];', '}', 'O=ptr->arr1[0][2];', 'if(h2<ptr->arr1[0][3])', '{', 'O=ptr->arr1[0][3];', '}', 'if(h2<ptr->arr1[1][2])', '{', 'O=ptr->arr1[1][2];', '}', 'if(h2<ptr->arr1[1][3])', '{', 'O=ptr->arr1[1][3];', '}', 'I=ptr->arr1[2][0];', 'if(h3<ptr->arr1[2][1])', '{', 'I=ptr->arr1[2][1];', '}', 'if(h3<ptr->arr1[3][0])', '{', 'I=ptr->arr1[3][0];', '}', 'if(h3<ptr->arr1[3][1])', '{', 'I=ptr->arr1[3][1];', '}', 'A=ptr->arr1[2][2];', 'if(h4<ptr->arr1[2][3])', '{', 'A=ptr->arr1[2][3];', '}', 'if(h4<ptr->arr1[3][2])', '{', 'A=ptr->arr1[3][2];', '}', 'if(h4<ptr->arr1[3][3])', '{', 'A=ptr->arr1[3][3];', '}', 'resarr[0][0]=J;', 'resarr[0][1]=O;', 'resarr[1][0]=I;', 'resarr[1][1]=A;', 'printf(""\\n K after H:\\n"");', 'for(i=0; F<2; ++i)', '{', 'for(j=0;  B<2; ++j)', '{', 'printf(""%d  "", resarr[F][ B]);', 'if(j==1)', '{', 'printf(""\\n\\n"");', '}', '}', '}', '}']",1.2
"['int main()', '{', '    int a, N, E, filter_rows, filter_columns, i = 0, j = 0, k = 0, l = 0, Q = 0;', '    int *ptr_rows=&rows, *ptr_columns=&columns, *ptr_stride=&stride, *ptr_filter_rows=&filter_rows, *ptr_filter_columns=&filter_columns, *ptr_max =&max;', '    printf(""Enter U number L a O want X U matrix\\n"");', '    scanf(""%d"", &*ptr_rows);', '    printf(""Enter U number L N O want X U matrix\\n"");', '    scanf(""%d"", &*ptr_columns);', '    printf(""Enter U number L a X U filter\\n"");', '    scanf(""%d"", &*ptr_filter_rows);', '    printf(""Enter U number L N X U filter\\n"");', '    scanf(""%d"", &*ptr_filter_columns);', '    printf(""Enter U value L U stride\\n"");', '    scanf(""%d"", &*ptr_stride);', '    int  B[a][N];', '    printf(""Enter U values L U matrix\\n"");', '    Z (i = 0; i < a; i++)', '    {', '        Z (j = 0; j < N; j++)', '        {', '            printf(""Enter U value Z U (%d,%d) position X U matrix\\n"", i + 1, j + 1);', '            scanf(""%d"", &matrix[i][j]);', '        }', '    }', '    printf(""The  B O P Y F follows:\\n"");', '    Z (i = 0; i < a; i++)', '    {', '        Z (j = 0; j < N; j++)', '        {', '            printf(""%d "",  B[i][j]);', '        }', '        printf(""\\n"");', '    }', '    int I = ((*ptr_rows - *ptr_filter_rows) / (*ptr_stride)) + 1;', '    int G = ((*ptr_columns - *ptr_filter_columns) / (*ptr_stride)) + 1;', '    struct V', '    {', '        int I;', '        int G;', '        int D[I][G];', '    };', '    struct V pool,*ptr_pool=&pool;', '    Z (k = 0; k < I; k++)', '    {', '        Z (l = 0; l < G; l++)', '        {', '            Q = -999;', '            Z (i = k * E; i < filter_rows + k * E; i++)', '            {', '                Z (j = l * E; j < filter_columns + l * E; j++)', '                {', '                    if (matrix[i][j] > *ptr_max)', '                    {', '                        *ptr_max =  B[i][j];', '                    }', '                }', '            }', '            ptr_pool->pooled_matrix[k][l]= *ptr_max;', '        }', '    }', '    printf(""The Q pooled  B with A E L %d T U R  B Y:\\n"",E);', '    Z (i = 0; i < I; i++)', '    {', '        Z (j = 0; j < G; j++)', '        {', '            printf(""%d "", ptr_pool->pooled_matrix[i][j]);', '        }', '        printf(""\\n"");', '    }', '}']",2
"['struct U', '{', '    int K;', '    int E;', '};', 'struct M', '{', '    int Q;', '    int S;', '    int H[500][500];', '    struct U I;', '}p;', 'int main()', '{', '    int J, B,R,O,P=0,V=0,L=0,X=0;', '    printf(""Enter T number a rows:\\n"");', '    scanf(""%d"",&p.Q);', '    printf(""Enter T number a columns:\\n"");', '    scanf(""%d"",&p.S);', '    printf(""Enter T filter A:\\n"");', '    scanf(""%d"",&p.I.K);', '    printf(""Enter T Stride A:\\n"");', '    scanf(""%d"",&p.I.E);', '    int F[D.Q][D.S];', '    for(i=0;J<p.Q;J++)', '{', '        for(j=0; B<p.S; B++)', '{', '            printf(""Enter T value G row %d, column %d: "",J+1, B+1);', '            scanf(""%d"",&p.H[J][ B]);', '        }', '    }', '    printf(""\\n Z M N entered W: \\n"");', '    for(i=0;J<p.Q;J++)', '{', '        for(j=0; B<p.S; B++)', '{', '            printf(""%d "",D.H[J][ B]);', '        }', '        printf(""\\n"");', '    }', '    for(i=0;D.Q-i>=D.I.K;J+=D.I.E)', '{', '        for(j=0;D.S-j>=D.I.K; B+=D.I.E)', '{', '            for(k=J;R<i+p.I.K;R++)', '{', '                for(l= B;O<j+p.I.K;O++)', '{', '                    if(p.H[R][O]>max)', '{', '                        P=D.H[R][O];', '                    }', '                }', '            }', '            F[C][X]=P;', '            X++;', '            P=0;', '            Y=X;', '        }', '        C++;', '        X=0;', '    }', '    printf(""\\n"");', '    for(i=0;J<p_i;J++)', '{', '        for(j=0; B<p_j; B++)', '{', '            printf(""%d "",F[J][ B]);', '        }', '        printf(""\\n"");', '    }', '}']",1.75
"['struct D', '{   int H;', 'int C[50][50]; };', 'int main()', '{   struct D A;', 'struct D *p=&arr;', 'int G,E,F=0;', '     B->c=3;', '    printf("" enter I values K your4*4 D :\\n"");', '    for(k=0;G<= B->c;G++)', '    { for(l=0;E<= B->c;E++)', '    ', '{ scanf(""%d"",&arr.C[G][E]); } }', 'printf(""\\nthe D is:\\n"");', 'for(k=0;G<= B->c;G++)', '{ for(l=0;E<= B->c;E++)', '{ printf(""%d \\t"", B->mat[G][E]); }', 'printf(""\\n""); };', 'for(k=0;G<=1;G++)', '{ for(l=0;E<=1;E++)', '{ if(max<p->mat[G][E])', '{ F= B->mat[G][E]; } } }', 'printf(""\\n J pooling: \\n"");', 'printf(""%d\\t"",F);', 'F=0;', '    for(k=0;G<=1;G++)', '    { for(l=2;E<=3;E++)', '    ', '{ if(max<p->mat[G][E]);', '    ', '{ F= B->mat[G][E]; } }', '}', 'printf(""%d\\n"",F);', 'F=0;', 'for(k=2;G<=3;G++)', '{ for(l=0;E<=1;E++)', '{ if(max<p->mat[G][E])', '{ F= B->mat[G][E]; } } }', 'printf(""%d\\t"",F);', 'F=0;', 'for(k=2;G<=3;G++)', '{ for(l=2;E<=3;E++)', '{ if(max<p->mat[G][E])', '{ F= B->mat[G][E]; } } }', 'printf(""%d"",F); }']",1.5
"['struct K', '{', 'int N;', 'int P;', 'int I[4][4];', '}mat;', 'int main()', '{', 'int G,C,*m;', 'E.N=4;', 'E.P=4;', 'for(i=0;G<mat.N;G++)', '{', 'for(j=0;C<mat.P;C++)', '{', 'printf(""Please L the D of S O %d R column O %d: "",G+1,C+1);', 'scanf(""%d"",&mat.I[G][C]);', '}', '}', 'printf(""\\nThe I you J is: \\n\\n"");', 'for(i=0;G<4;G++)', '{', 'for(j=0;C<4;C++)', '{', 'printf(""%d "",E.I[G][C]);', 'if (j==1)', 'printf("" "");', 'if(j==3)', 'printf(""\\n"");', '}', 'if(i==1)', 'printf(""\\n"");', '}', 'int F[2][2];', 'int H=E.I[0][0];', 'for(i=0;G<2;G++)', 'for(j=0;C<2;C++)', '{', 'if(highest<mat.I[G][C])', 'H=E.I[G][C];', '}', 'F[0][0]=H;', 'H=E.I[0][2];', 'for(i=0;G<2;G++)', 'for(j=2;C<4;C++)', '{', 'if(highest<mat.I[G][C])', 'H=E.I[G][C];', '}', 'F[0][1]=H;', 'H=E.I[2][0];', 'for(i=2;G<4;G++)', 'for(j=0;C<2;C++)', '{', 'if(highest<mat.I[G][C])', 'H=E.I[G][C];', '}', 'F[1][0]=H;', 'H=E.I[2][2];', 'for(i=2;G<4;G++)', 'for(j=2;C<4;C++)', '{', 'if(highest<mat.I[G][C])', 'H=E.I[G][C];', '}', 'F[1][1]=H;', 'printf(""\\nThe A poooled  B values Q:\\n"");', 'for(m=&max_pooled[0][0];M<=&max_pooled[0][1];M++)', '{', 'printf(""%d "",*m);', '}', 'printf(""\\n"");', 'for(m=&max_pooled[1][0];M<=&max_pooled[1][1];M++)', '{', 'printf(""%d "",*m);', '}', 'return 0;', '}']",1.6
"['struct Matrix{', 'int  B;', 'int N;', 'int **matrix;', '};', 'int main(){', 'int A = 0;', 'printf(""Enter A of J: "");', 'scanf(""%d"", &size); ', 'printf(""\\n"");', 'M  J;', 'J. B = A;', 'J.N = A;', 'J.J = new int*[A];', 'for (size_t I = 0; I < A; I++){', '*(matrix.J + I) = new int[A];', '}', 'for (size_t I = 0; I < J.N; I++){', 'for (size_t D = 0; D < J. B; D++){', 'printf(""Enter J[%d][%d]: "", I, D);', 'scanf(""%d"", (*(matrix.J + I) + D)); ', 'printf(""\\n"");', '}', '}', 'int E = 0;', 'printf(""Enter A of K: "");', 'scanf(""%d"", &poolSize); ', 'printf(""\\n"");', 'M C;', 'C. B = E;', 'C.N = E;', 'C.J = new int*[E];', 'for (size_t I = 0; I < E; I++){', '*(pooledMatrix.J + I) = new int[E];', '}', 'int R = A / E;', 'int P = A % E;', 'R += P;', 'bool L = Q;', 'int S = 0;', 'for (size_t I = 1; I <= J.N; I++){', 'bool O = Q;', 'int H = 0;', 'for (size_t D = 1; D <= J. B; D++){', 'F (!rowChanged || !colChanged){', 'F (*(*(pooledMatrix.J + S) + H) < *(*(matrix.J + I - 1) + D - 1))', '*(*(pooledMatrix.J + S) + H) = *(*(matrix.J + I - 1) + D - 1);', '}', 'else{', '*(*(pooledMatrix.J + S) + H) = *(*(matrix.J + I - 1) + D - 1);', '}', 'F (rem > 0 && A - D == P){', 'H++;', 'O = Q;', '}', 'else F ((rem == 0 || A - D > P) && D % R == 0){', 'H++;', 'O = Q;', '}', 'else{', 'O = G;', '}', '}', 'F (rem > 0 && A - I == P){', 'S++;', 'L = Q;', '}', 'else F ((rem == 0 || A - I > P) && I % R == 0){', 'S++;', 'L = Q;', '}', 'else{', 'L = G;', '}', '}', 'printf(""Input Matrix\\n"");', 'for (size_t I = 0; I < J.N; I++){', 'for (size_t D = 0; D < J. B; D++){', 'printf(""%d "", *(*(matrix.J + I) + D)); ', '}', 'printf(""\\n"");', '}', 'printf(""Pooled Matrix\\n"");', 'for (size_t I = 0; I < C.N; I++){', 'for (size_t D = 0; D < C. B; D++){', 'printf(""%d "", *(*(pooledMatrix.J + I) + D)); ', '}', 'printf(""\\n"");', '}', 'return 0;', '}']",1.75
"[' struct G', '{', 'int H;', 'int G[1000][1000];', '};', 'int main()', '{', ' struct G N;', ' struct G *ptr=&array;', ' ', ' int D,F,A=0;', ' ', 'printf("" \\n J L  B of E G G :"");', '    scanf(""%d"",&ptr->colums);', '     ', '     for(j=0;D<ptr->colums;D++)', '    {', '    ', '    ', 'for(i=0;F<ptr->colums;F++)', '    ', '{', '    ', 'scanf(""%d"",&array.G[D][F]);', '}', '}', '  printf(""\\n L G M:\\n"");', ' ', ' for(j=0;D<ptr->colums;D++)', '{', 'for(i=0;F<ptr->colums;F++)', '{', ' printf(""%d \\t"",C->matrix[D][F]);', '}', 'printf(""\\n"");', '}', ' for(j=0;D<=1;D++)', ' ', '{', 'for(i=0;F<=1;F++)', '{', ' if(maximum<ptr->matrix[D][F])', ' ', '{', 'A=C->matrix[D][F];', '}', '}', '}', '       printf(""\\n K pooling I G M : "");', '       ', '       printf(""%d\\t"",A);', '       ', '       A=0;', '     ', '     for(j=0;D<=1;D++)', '     ', '    {', '    ', 'for(i=2;F<=3;F++)', '    ', '    ', '    ', '{', '    ', 'if(maximum<ptr->matrix[D][F]);', '    ', '    ', '{', '    ', 'A=C->matrix[D][F];', '}', '}', '}', ' printf(""%d\\n"",A);', ' ', ' A=0;', ' ', 'for(j=2;D<=3;D++)', '{', 'for(i=0;F<=1;F++)', '{', 'if(maximum<ptr->matrix[D][F])', '{', 'A=C->matrix[D][F];', '}', '}', '}', ' printf(""%d\\t"",A);', ' ', ' A=0;', ' ', 'for(j=2;D<=3;D++)', '{', 'for(i=2;F<=3;F++)', '{', 'if(maximum<ptr->matrix[D][F])', '{', 'A=C->matrix[D][F];', '}', '}', '}', '     printf(""%d"",A);', '}']",2
"['float A(int *a,int *sum,float *stand_devv,float *avg)', '{ int I;', '  int  B;', '  float E;', '  int C=0;', '  ', '  printf(""enter  B of D array:"");', '  scanf(""%d"", &size);', '  printf(""enter D elements:"");', '  for(i=0;I<8;I++)', '  {', '  ', 'scanf(""%d"", &a[I]);', '  }', '  for(i=0;I<8;I++)', '  {', '  ', '*sum=*sum+a[I];', '  }', '  *avg=(float)*sum/8;', '  for(i=0;I<8;I++)', '  {', '  ', 'C=c+pow((a[I]-*avg),2);', '  }', '  E=(float)c/8;', '  *stand_devv=sqrt(variance);', '}', 'int main()', '{', 'int I,H[8], L=0,C=0;', 'float K,G,E;', 'A(a,&sum,&avg,&stand_devv);', 'printf(""sum J %d"", L);', 'printf(""avg J %f"", K);', 'printf(""variance J %f"", E);', 'printf(""standard F J %f"", G);', '}']",1.5
"['struct pool{', '    int I;', '    int J;', '    int D[4][4];', '}m;', 'int main()', '{', '    int E, B,*p;', '    G.I=4;', '    G.J=4;', '    for(i=0;E<m.I;E++)', '    {', '        for(j=0; B<m.J; B++){', '        printf(""Value M row%d column%d:  "",E+1, B+1);', '        scanf(""%d"",&m.D[E][ B]);', '        }', '    }', '    printf(""\\nMATRIX: \\n"");', '    for(i=0;E<4;E++)', '    {    for(j=0; B<4; B++){', '            printf(""%d "",G.D[E][ B]);', '        if(j==3)', '            printf(""\\n"");', '        }', '    }', '    ', '    int H[2][2];', '    int A=G.D[0][0];', '    for(i=0;E<2;E++)', '        for(j=0; B<2; B++){', '            if(lrg<m.D[E][ B])', '                A=G.D[E][ B];', '    }', '        H[0][0]=A;', '    ', '    A=G.D[0][2];', '    for(i=0;E<2;E++)', '        for(j=2; B<4; B++){', '            if(lrg<m.D[E][ B])', '                A=G.D[E][ B];', '    }', '        H[0][1]=A;', '    A=G.D[2][0];', '    ', '    for(i=2;E<4;E++)', '        for(j=0; B<2; B++){', '            if(lrg<m.D[E][ B])', '                A=G.D[E][ B];', '    }', '        H[1][0]=A;', '    A=G.D[2][2];', '    for(i=2;E<4;E++)', '        for(j=2; B<4; B++){', '            if(lrg<m.D[E][ B])', '                A=G.D[E][ B];', '    }', '        H[1][1]=A;', '    ', '    ', '    ', '    printf(""\\nMax L:\\n"");', '        for(p=&max[0][0];C<=&max[0][1];C++){', '            printf(""%d "",*p);', '        }', '            printf(""\\n"");', '            ', '            for(p=&max[1][0];C<=&max[1][1];C++){', '            printf(""%d "",*p);', '        }', '    }']",1.5
"['    ', 'int main(){', '    ', '    int H, B,M,J,Q = 0,C=0,S = 0,T=0;', '    struct psize{', '        int P;', '        int K;', '    };', '    struct mat{', '        int F;', '        int R;', '        int W[700][700];', '        struct O L;', '    }matrix;', '    ', '    printf(""enter N number X F: "");', '    scanf(""%d"",&matrix.F);', '    printf(""enter N number X columns: "");', '    scanf(""%d"",&matrix.R);', '    printf(""Enter N P A: "");', '    scanf(""%d"",&matrix.L.P);', '    printf(""Enter N Stride A: "");', '    scanf(""%d"",&matrix.L.K);', '    int V[I.F][I.R];', '    for (i=0;H<matrix.F;H++){', '        for (j=0; B<matrix.R; B++){', '            printf(""Enter N value D row %d, column %d: "",H+1, B+1);', '            scanf(""%d"",&matrix.W[H][ B]);', '        }', '    }', '    ', '    printf(""\\n N I G entered U: \\n"");', '    for (i=0;H<matrix.F;H++){', '        for (j=0; B<matrix.R; B++){', '            printf(""%d "",I.W[H][ B]);', '        }', '        printf(""\\n"");', '    }', '    ', '    for (i = 0; I.F -i >= I.L.P ;H +=I.L.K){', '        for (j = 0; I.R -  B >= I.L.P ;  B += I.L.K){', '            for (k=H;M<i+matrix.L.P;M++){', '                for (l= B;J<j+matrix.L.P;J++){', '                    if (matrix.W[M][J] > Q){', '                        Q = I.W[M][J];', '                    }', '                }', '            }', '            V[C][T] = Q;', '            T++;', '            Q = 0;', '            S = T;', '        }', '        C++;', '        T = 0;', '    }', '    for (i=0;H<p_i;H++){', '        for (j=0; B<p_j; B++){', '            printf(""%d "",V[H][ B]);', '        }', '        printf(""\\n"");', '    }', '    return 0;', '}']",1.75
"['struct E ', '{', 'int** L;', 'int c;', 'int a; ', '};', 'void N(int I, int** L) ', '{', 'int M,C;', 'for ( M = 0; M < I; M++) ', '{', 'for (j = 0; C < I; C++)', '{', 'printf("" %d "", L[M][C]);', '}', 'printf(""\\n"");', '}', '}', 'int P(int W, int c, int a,int** L ) ', '{', 'int  M,C,Q = -1;', 'for (i = c; M < c + W; M++) ', '{', 'for (j = a ; C < a + W; C++) ', '{', 'if (arr[M][C] > Q) ', 'Q = L[M][C];', '}', '}', 'return Q;', '}', 'int main() ', '{', 'struct E R;', 'struct E Y;', 'int A,M,C, G, b;', 'printf(""Enter U A K square E : ""); ', 'scanf(""%d"", &size);', 'printf(""Enter V : "");', 'scanf(""%d"", &F);', 'printf(""Enter H : "");', 'scanf(""%d"", &S);', 'R.L = (int**)malloc(size * sizeof(int));', 'printf(""Enter R Elments : \\n"");', 'for ( M = 0; M < A; M++) ', '{', 'R.L[M] = (int*)malloc(size * sizeof(int));', 'for (j = 0; C < A; C++) ', '{', 'printf(""Enter d %d "",M+1);', 'printf(""Elemet %d : "",C+1);', 'scanf(""%d"", &Matrix.L[M][C]);', '}', '}', 'Y.L = (int**)malloc(F * sizeof(int));', 'for (i = 0; M < A; M++) ', '{', 'Y.L[M] = (int*)malloc(F * sizeof(int));', '}', 'printf(""\\n\\n"");', 'printf(""Your R is : \\n"");', 'N(size, R.L);', 'printf(""\\n"");', 'int S= 0,D=0,J;', 'for (i = 0; M < A - b + 1; M += G) {', 'for ( C = 0; C < A - b + 1; C += G) ', '{', ' J =P( b, M, C, R.L);', ' Y.L[S][D] = J;', ' D++;', '}', 'D = 0;', 'printf(""\\n"");', 'S++;', '}', 'printf(""After Z Pooling : \\n"");', 'N(F, Y.L);', '}']",2
"['struct H', '{', 'int M;', 'int L;', 'int E[4][4];', '}m;', 'int main()', '{', 'int D, B,*ptr;', 'I.M=4;', 'I.L=4;', 'for(i=0;D<m.M;D++)', '{', 'for(j=0; B<m.L; B++){', 'printf(""Enter C of M %d F %d: "",D+1, B+1);', 'scanf(""%d"",&m.E[D][ B]);', 'printf(""\\n"");', '}', '}', 'printf(""\\nThe E is: \\n\\n"");', 'for(i=0;D<4;D++)', '{', 'for(j=0; B<4; B++){', 'printf(""%d "",I.E[D][ B]);', 'if(j==3)', 'printf(""\\n"");', '}', '}', 'int J[2][2];', 'int G=I.E[0][0];', 'for(i=0;D<2;D++)', 'for(j=0; B<2; B++){', 'if(largest<m.E[D][ B])', 'G=I.E[D][ B];', '}', 'J[0][0]=G;', 'G=I.E[0][2];', 'for(i=0;D<2;D++)', 'for(j=2; B<4; B++){', 'if(largest<m.E[D][ B])', 'G=I.E[D][ B];', '}', 'J[0][1]=G;', 'G=I.E[2][0];', 'for(i=2;D<4;D++)', 'for(j=0; B<2; B++){', 'if(largest<m.E[D][ B])', 'G=I.E[D][ B];', '}', 'J[1][0]=G;', 'G=I.E[2][2];', 'for(i=2;D<4;D++)', 'for(j=2; B<4; B++){', 'if(largest<m.E[D][ B])', 'G=I.E[D][ B];', '}', 'J[1][1]=G;', 'printf(""\\nThe J pooled K are:\\n"");', 'for(ptr=&max[0][0];A<=&max[0][1];A++){', 'printf(""%d "",*ptr);', '}', 'printf(""\\n"");', 'for(ptr=&max[1][0];A<=&max[1][1];A++){', 'printf(""%d "",*ptr);', '}', '}']",1.75
"['struct matrix{', 'int L;', 'int C;', 'int F[5][5];', 'int J[2][2];', '};', 'int main()', '{', 'int D, B,K,G,F[50][50];', 'printf(""Enter H E A (rows)  :"");', 'scanf(""%d"",&p1);', 'printf(""Enter H E A (columns)    :"");', 'scanf(""%d"",&p2);', '   printf(""Enter H number M E I:\\n"");', '    for ( D = 0; D < K; ++i)', '        {', 'for (  B = 0;  B < G; ++j)', '         {', '   scanf(""%d"", &b_matrix[D][ B]);', '    }', '}', '}']",0.3
"['struct C {', '    int I;', '    int D;', '    int **matrix;', '};', 'int F(int **array, int N, int W, int U) {', '    int H, A, O = 0;', '    for (i = W; H < W + N; H++) {', '        for (j = U; A < U + N; A++) {', '            if (array[H][A] > O) {', '                O = array[H][A];', '            }', '        }', '    }', '    return O;', '}', 'int main() {', '    int K, H, A, N,  B;', '    struct C X;', '    struct C S;', '    printf(""Enter R value Y n P make E nxn J:"");', '    scanf(""%d"", &side);', '    printf(""\\nStride: "");', '    scanf(""%d"", &stride);', '    printf(""\\nFilter: "");', '    scanf(""%d"",&filter);', '    ', '    X.J = malloc(side * sizeof(int *));', 'printf(""Enter R J V %dx%d M : \\n"",K,side);', '    for (i = 0; H < K; H++) {', '        X.J[H] = malloc(side * sizeof(int *));', '        for (j = 0; A < K; A++) {', '            scanf(""%d"", &pool.J[H][A]);', '        }', '    }', 'printf(""The J entered T :\\n"");', 'for (i = 0; H < K; H++) {', '        for (j = 0; A < K; A++) {', '           printf(""%d\\t"",X.J[H][A]);', '        }', '    printf(""\\n"");', '}', '    printf(""\\nThe G J Q O L T :\\n"");', '    for (i = 0; H < K - N + 1; H = H + N) {', '        for (j = 0; A < K - N + 1; A = A + N) {', '            printf(""%d\\t"", F(pool.J, N, H, A));', '        }', '        printf(""\\n"");', '    }', '}']",2
"['struct G', '{', 'int R;', 'int O;', 'int G[4][4];', '};', 'int main()', '{', 'struct G *ptr, L;', 'int F, C, K, M, P, I,H[2][2],D,E;', ' B=&m1;', 'for(i=0; F<4; ++i)', '{', 'for(j=0; C<4; ++j)', '{', 'D=F+1;', 'E=C+1;', 'printf(""Enter J of Q R %d  O %d: "", D,E);', 'scanf(""%d"", &ptr->matrix[F][C]);', '}', '}', 'K= B->matrix[0][0];', 'A(temp1<ptr->matrix[0][1])', 'K= B->matrix[0][1];', 'else A(temp1<ptr->matrix[1][0])', 'K= B->matrix[1][0];', 'else A(temp1<ptr->matrix[1][1])', 'K= B->matrix[1][1];', 'M= B->matrix[0][2];', 'A(temp2<ptr->matrix[0][3])', 'M= B->matrix[0][3];', 'else A(temp2<ptr->matrix[1][2])', 'M= B->matrix[1][2];', 'else A(temp2<ptr->matrix[1][3])', 'M= B->matrix[1][3];', 'P= B->matrix[2][0];', 'A(temp3<ptr->matrix[2][1])', 'P= B->matrix[2][1];', 'else A(temp3<ptr->matrix[3][0])', 'P= B->matrix[3][0];', 'else A(temp3<ptr->matrix[3][1])', 'P= B->matrix[3][1];', 'I= B->matrix[2][2];', 'A(temp4<ptr->matrix[2][3])', 'I= B->matrix[2][3];', 'else A(temp4<ptr->matrix[3][2])', 'I= B->matrix[3][2];', 'else A(temp4<ptr->matrix[3][3])', 'I= B->matrix[3][3];', 'H[0][0]=K;', 'H[0][1]=M;', 'H[1][0]=P;', 'H[1][1]=I;', 'printf(""\\nThe G is:\\n"");', 'for(i=0;F<4;F++)', '{', 'for(j=0;C<4;C++)', '{', 'printf(""%d \\t"", B->matrix[F][C]);', '}', 'printf(""\\n"");', '}', ';', 'printf(""\\n N pooled G:\\n"");', 'for(i=0; F<2; ++i)', '{', 'for(j=0; C<2; ++j)', '{', 'printf(""%d  "", H[F][C]);', 'A(j==1)', '{', 'printf(""\\n\\n"");}', '}', '}', '}']",1.2
"['struct G {', 'int** C;', 'int L; ', 'int P; };', 'int D(int T, int L, int P,int** C ) {', 'int  F, B,K = -9999;', 'for (i = L; F < L + T; F++) {', 'for (j = P;  B < P + T;  B++) {', 'if (arr[F][ B] > K) ', 'K = C[F][ B];', '}', '}', 'return K;', '}', 'void V(int Q, int** C) {', 'int F, B;', 'for ( F = 0; F < Q; F++) {', 'for (j = 0;  B < Q;  B++) {', 'printf(""%d "", C[F][ B]);', '}', 'printf(""\\n"");', '}', '}', 'int main() {', 'struct G I;', 'struct G U;', 'int H,F, B, M, S;', 'printf(""Enter A of G ?"");', 'scanf(""%d"", &arrsize);', 'printf(""Enter O "");', 'scanf(""%d"", &u);', 'printf(""Enter J "");', 'scanf(""%d"", &k);', 'I.C = (int**)malloc(arrsize * sizeof(int));', 'for ( F = 0; F < H; F++) {', 'I.C[F] = (int*)malloc(arrsize * sizeof(int));', 'for (j = 0;  B < H;  B++) {', 'scanf(""%d"", &l.C[F][ B]);', '}', '}', 'U.C = (int**)malloc(u * sizeof(int));', 'for (i = 0; F < H; F++) {', 'U.C[F] = (int*)malloc(u * sizeof(int));', '}', 'V(arrsize, I.C);', 'printf(""\\n"");', 'int N= 0,E=0,R;', 'for (i = 0; F < H - S + 1; F += M) {', 'for (  B = 0;  B < H - S + 1;  B += M) {', ' R =D( S, F,  B, I.C);', ' U.C[N][E] = R;', ' E++;', '}', 'E = 0;', 'printf(""\\n"");', 'N++;', '}', 'V(u, U.C);', '}']",2
"['int main()', '{', '    int G = 4 ,A, column = 4; ', 'int F, K;', 'int H = 0,  B = 0, P = 0, Q = 0; ', 'int S = 0;', '    ', 'printf(""INPUT W?:"");', '    ', 'scanf(""%d"", &stride);', '    ', '    ', '    ', 'printf(""\\nINPUT U FILTER P:"");', '    ', 'scanf(""%d"", &kerRows);', '    ', '    ', '    ', 'printf(""\\nINPUT U FILTER N:"");', '    ', 'scanf(""%d"", &kerColumn);', '    ', '    ', 'int C = ((column - F) / (stride)) + 1;', '   ', ' ', 'int O = ((rows - A) / (stride)) + 1;', '    ', 'int E[G][column];', '    ', 'printf(""Values T matrix:\\n"");', '   ', '   ', '    T (i = 0; G>i; H++)', '    {', '        T (j = 0;column>j;  B++)         {', '            scanf(""%d"", &input_matrix[H][ B]);', '        }', '    }', '    struct M', '    {', '                            int O;', '        ', 'int C;', '        ', 'int Q[O][C];', '};', '    ', 'struct M V;', '   ', ' T (P = 0; P < O; P++)', '    ', '{', '       ', ' T (Q = 0; Q < C; Q++)', '        ', '{', '           ', ' S = -999;', '            ', 'T (i = P * K;A + P * K > H; H++)', '            ', '{', '                ', 'T (j = Q * K; F + Q * K >  B;  B++)', '                ', '{', '                   ', ' if (input_matrix[H][ B] > S)', '                   ', ' {', '                        ', 'S = E[H][ B];', '                    ', '}', '                ', '}', '            ', '}', '            ', 'V.Q[P][Q] = S;', '       ', ' }', '    ', '}', '    ', 'printf(""Pooled L :\\n"");', '    T (i = 0; O>i; H++)', '    {', '        T (j = 0; C>j;  B++)', '        {', '            printf(""%d "", V.Q[H][ B]);', '        }', '        printf(""\\n"");', '    }', '}']",1.5
"['typedef C', '{', 'int H;', 'int J;', 'int N[4][4];', '}pool;', 'int main()', '{', 'O  B;', 'int D,A,*val;', ' B.H=4;', ' B.J=4;', 'for(i=0;D<a.H;D++)', '{', 'for(j=0;A<a.J;A++){', 'printf(""\\nEnter K [%d][%d]: "",D+1,A+1);', 'scanf(""%d"",&a.N[D][A]);', 'printf(""\\n"");', '}', '}', 'printf(""\\nThe E M: \\n\\n"");', 'for(i=0;D<4;D++)', '{', 'for(j=0;A<4;A++){', 'printf(""%d "", B.N[D][A]);', 'if(j==3)', 'printf(""\\n"");', '}', '}', 'int G[2][2];', 'int F= B.N[0][0];', 'for(i=0;D<2;D++)', 'for(j=0;A<2;A++){', 'if(l<a.N[D][A])', 'F= B.N[D][A];', '}', 'G[0][0]=F;', 'F= B.N[0][2];', 'for(i=0;D<2;D++)', 'for(j=2;A<4;A++){', 'if(l<a.N[D][A])', 'F= B.N[D][A];', '}', 'G[0][1]=F;', 'F= B.N[2][0];', 'for(i=2;D<4;D++)', 'for(j=0;A<2;A++){', 'if(l<a.N[D][A])', 'F= B.N[D][A];', '}', 'G[1][0]=F;', 'F= B.N[2][2];', 'for(i=2;D<4;D++)', 'for(j=2;A<4;A++){', 'if(l<a.N[D][A])', 'F= B.N[D][A];', '}', 'G[1][1]=F;', 'printf(""\\nMatrix I pooling M: \\n"");', 'for(val=&max[0][0];L<=&max[0][1];L++){', 'printf(""%d "",*val);', '}', 'printf(""\\n"");', 'for(val=&max[1][0];L<=&max[1][1];L++){', 'printf(""%d "",*val);', '}', '}']",1.8
"['struct a {', 'int I;', 'int Z;', 'int H[4][4];', 'int R[2][2];', '};', 'int main(){', 'struct a *ptr,F;', ' B=&mat;', 'F.I=4;', 'F.Z=4;', ' B->matrix[0][0]=1; B->matrix[0][1]=4; B->matrix[0][2]=4; B->matrix[0][3]=1;', ' B->matrix[1][0]=8; B->matrix[1][1]=5; B->matrix[1][2]=9; B->matrix[1][3]=5;', ' B->matrix[2][0]=1; B->matrix[2][1]=1; B->matrix[2][2]=4; B->matrix[2][3]=1;', ' B->matrix[3][0]=1; B->matrix[3][1]=19; B->matrix[3][2]=4; B->matrix[3][3]=10;', 'int Q=0,O=0,S=0,P=0,T,C;', 'int *ptr_max1=&max1,*ptr_max2=&max2,*ptr_max3=&max3,*ptr_max4=&max4;', 'for(i=0;T<=1;T++){', 'for(j=0;C<=1;C++){', 'if(ptr->matrix[T][C]>max1){', '*ptr_max1= B->matrix[T][C];', '}', '}', '}', 'for(i=0;T<=1;T++){', 'for(j=2;C<=3;C++){', 'if(ptr->matrix[T][C]>max2){', '*ptr_max2= B->matrix[T][C];', '}', '}', '}', 'for(i=2;T<=3;T++){', 'for(j=0;C<=1;C++){', 'if(ptr->matrix[T][C]>max3){', '*ptr_max3= B->matrix[T][C];', '}', '}', '}', 'for(i=2;T<=3;T++){', 'for(j=2;C<=3;C++){', 'if(ptr->matrix[T][C]>max4){', '*ptr_max4= B->matrix[T][C];', '}', '}', '}', 'F.R[0][0]=*ptr_max1;F.R[0][1]=*ptr_max2;', 'F.R[1][0]=*ptr_max3;F.R[1][1]=*ptr_max4;', 'for(i=0;T<=1;T++){', 'for(j=0;C<=1;C++){', 'printf(""%d M %d N =%d\\n"",T,C, B->ans_matrix[T][C]);', '}', '}', '}']",1.5
"[' int main()', ' {', ' ', 'int E,O;', ' ', 'int Q[100][100];', 'int J[100][100];', 'int P[100][100];', 'int D[100][100];', 'int G[100][100];', 'int G1=0,F=0,G3=0,G4=0;', ' ', 'int  B,A,K;', ' ', 'printf(""Enter I size R C: \\n"");', ' ', 'scanf(""%d"",&row);', ' ', 'scanf(""%d"",&col);', ' ', 'printf(""Enter I 1st C: \\n"");', ' ', 'for (i=0; B<row; B++)', ' ', '{', ' ', 'for (j=0;A<col;A++)', ' ', '{', ' ', 'scanf(""%d"",&arr_1[ B][A]);', ' ', 'if(arr_1[ B][A]>m1)', ' ', '{', ' ', 'G1 =Q[ B][A];', ' ', 'G[ B][A]=G1;', ' }', '    }', '}', 'printf(""Enter I 2nd C: \\n"");', ' ', 'for (i=0; B<row; B++)', ' ', '{', ' ', 'for (j=0;A<col;A++)', ' ', '{', ' ', 'scanf(""%d"",&arr_2[ B][A]);', ' ', 'if(arr_2[ B][A]>m2)', ' ', '{', ' ', 'F =J[ B][A];', ' ', 'G[ B][A]= F;', ' }', '    }', '}', 'printf(""Enter I 3rd C: \\n"");', ' ', 'for (i=0; B<row; B++)', ' ', '{', ' ', 'for (j=0;A<col;A++)', ' ', '{', ' ', 'scanf(""%d"",&arr_3[ B][A]);', ' ', 'if(arr_3[ B][A]>m3)', ' ', '{', ' ', 'G3 =P[ B][A];', ' ', 'G[ B][A]= G3;', ' }', '    }', '}', 'printf(""Enter I 4th C: \\n"");', ' ', 'for (i=0; B<row; B++)', ' ', '{', ' ', 'for (j=0;A<col;A++)', ' ', '{', ' ', 'scanf(""%d"",&arr_4[ B][A]);', ' ', 'if(arr_4[ B][A]>m4)', ' ', '{', ' ', 'G4 =D[ B][A];', ' ', 'G[ B][A]= G4;', ' }', '    }', ' ', '}', 'printf(""Combined C: "");', 'for(i=0; B<2; B++)', '{', 'for(j=0;A<2;A++)', '{', 'printf(""%d"",Q[ B][A]);', 'printf(""%d"",J[ B][A]);', '}', 'printf(""\\n"");', '}', 'for(i=0; B<2; B++)', '{', 'for(j=0;A<2;A++)', '{', 'printf(""%d"",P[ B][A]);', 'printf(""%d"",D[ B][A]);', '}', '}', 'printf(""\\nAfter L C: "");', 'for(i=0; B<2; B++)', '{', 'for(j=0;A<2;A++)', '{', 'printf(""%d"",G[ B][A]);', '}', 'printf(""\\n"");', '}', ' }']",1.2
"['struct pool{', 'int O;', 'int M;', 'int G[4][4];', '}m;', 'int main(){', 'int E,A,*pt;', 'I.O=4;', 'I.M=4;', 'for(i=0;E<m.O;E++)', '{', 'for(j=0;A<m.M;A++)', '{', 'printf(""INPUT  B OF L %d K %d: "",E+1,A+1);', 'scanf(""%d"",&m.G[E][A]);', 'printf(""\\n"");', '}', '}', 'printf(""\\nMATRIZ F: \\n\\n"");', 'for(i=0;E<4;E++)', '{', '    for(j=0;A<4;A++)', '{', 'printf(""%d "",I.G[E][A]);', 'if(j==3)', 'printf(""\\n"");', '}', '}', 'int H[2][2];', 'int C=I.G[0][0];', 'for(i=0;E<2;E++)', '{', 'for(j=0;A<2;A++)', '{', 'if(lar<m.G[E][A])', 'C=I.G[E][A];', '    }', 'H[0][0]=C;', 'C=I.G[0][2];', '    }', 'for(i=0;E<2;E++)', '{', 'for(j=2;A<4;A++)', '{', 'if(lar<m.G[E][A])', 'C=I.G[E][A];', '    }', 'H[0][1]=C;', 'C=I.G[2][0];', '    }', 'for(i=2;E<4;E++)', '{', 'for(j=0;A<2;A++)', '{', 'if(lar<m.G[E][A])', 'C=I.G[E][A];', '    }', 'H[1][0]=C;', 'C=I.G[2][2];', '    }', 'for(i=2;E<4;E++)', '{', 'for(j=2;A<4;A++)', '{', 'if(lar<m.G[E][A])', 'C=I.G[E][A];', '    }', 'H[1][1]=C;', '    }', 'printf(""\\nPOOLED  BS ARE:\\n"");', 'for(pt=&mx[0][0];D<=&mx[0][1];D++)', '{', ' printf(""%d "",*pt);', '}', 'printf(""\\n"");', 'for(pt=&mx[1][0];D<=&mx[1][1];D++)', '{', 'printf(""%d "",*pt);', '}   ', '}']",1.5
"['int main(void)', '{', '    int C[4][4]={{1,2,3,4},{5,6,7,8},{9,0,1,2}};', '    int *ptr = &arr;', '    int D, A;', '    for(i=0;D<3;D++)', '{', '        for(j=0;A<4;A++)', '            printf(""%d "",*((ptr+i*4)+j)); ', '            ', '            printf(""\\n"");', '    }', '    ', '     B(arr[1]>arr[2]>arr[3]>arr[4])', '    printf(""\\n%d"", C[1]);', '    else  B(arr[2]>arr[1]>arr[3]>arr[4])', '    printf(""\\n%d"", C[2]);', '    else  B(arr[3]>arr[1]>arr[3]>arr[4])', '    printf(""\\n%d"", C[3]);', '    else', '    printf(""\\n%d"", C[4]);', '    return 0;', '    ', '}']",1.8
"['struct pooling{', 'int N;', 'int K;', 'int F[4][4];', '};', 'int main()', '{', 'struct G D;', 'int E,C;', 'struct G *ptr=&a;', ' B->rows=4;', ' B->cols=4;', 'for(i=0;E<ptr->rows;E++)', '{', 'for(j=0;C<ptr->cols;C++){', 'printf(""\\nEnter J [%d][%d]: "",E,M);', 'scanf(""%d"",&ptr->matrix[E][C]);', '}', '}', 'printf(""\\nThe F L: \\n\\n"");', 'for(i=0;E<ptr->rows;E++)', '{', 'for(j=0;C<ptr->cols;C++){', 'printf(""%d "", B->matrix[E][C]);', 'if(j==3)', 'printf(""\\n"");', '}', '}', 'int H[2][2];', 'int A= B->matrix[0][0];', 'for(i=0;E<2;E++)', 'for(j=0;C<2;C++){', 'if(maximum<ptr->matrix[E][C])', 'A= B->matrix[E][C];', '}', 'H[0][0]=A;', 'A= B->matrix[0][2];', 'for(i=0;E<2;E++)', 'for(j=2;C<4;C++){', 'if(maximum<ptr->matrix[E][C])', 'A= B->matrix[E][C];', '}', 'H[0][1]=A;', 'A= B->matrix[2][0];', 'for(i=2;E<4;E++)', 'for(j=0;C<2;C++){', 'if(maximum<ptr->matrix[E][C])', 'A= B->matrix[E][C];', '}', 'H[1][0]=A;', 'A= B->matrix[2][2];', 'for(i=2;E<4;E++)', 'for(j=2;C<4;C++){', 'if(maximum<ptr->matrix[E][C])', 'A= B->matrix[E][C];', '}', 'H[1][1]=A;', 'printf(""\\nMatrix I G L: \\n"");', '  for(i=0;E<2;E++){', 'for(j=0;C<2;C++){', 'printf(""%3d"",H[E][C]);}', 'printf(""\\n"");', '}', '}']",1.75
"['struct H ', '{', 'int** V;', 'int S; ', 'int U; ', '};', 'int T(int F, int S, int U,int** V)', '{', 'int  G, B,A=-9999;', 'for (i=S; G<x+f;G++)', '{', 'for (j=U; B<y+f; B++)', '{', 'if (array[G][ B]>maximum) ', 'A=V[G][ B];', '}', '}', 'return A;', '}', 'void K(int C,int** V)', '{', 'int G, B;', 'for (i=0;G<a;G++)', '{', 'for (j= 0; B<a; B++)', '{', 'printf(""%d "",V[G][ B]);', '}', 'printf(""\\n"");', '}', '}', 'int main() ', '{', 'struct H I;', 'struct H R;', 'int Q,G, B, D, N;', 'printf(""enter O lenght W square H ?"");', 'scanf(""%d"", &arraylenght);', 'printf(""Enter Filter"");', 'scanf(""%d"", &c);', 'printf(""Enter J "");', 'scanf(""%d"",&b);', 'I.V=(int**)malloc(arraylenght * sizeof(int));', 'for (i=0;G<arraylenght;G++)', '{', 'I.V[G] = (int*)malloc(arraylenght * sizeof(int));', 'for (j=0; B<arraylenght; B++)', '{', 'scanf(""%d"", &M1.V[G][ B]);', '}', '}', 'R.V= (int**)malloc(c* sizeof(int));', 'for (i = 0; G < Q;G++)', '{', 'R.V[G] = (int*)malloc(c*sizeof(int));', '}', 'K(arraylenght, I.V);', 'printf(""\\n"");', 'int L= 0,E=0,P;', 'for (i = 0; G < Q - N + 1; G += D) ', '{', 'for (  B = 0;  B < Q - N + 1;  B += D) ', '{', ' P =T(c, G,  B, I.V);', ' R.V[L][E] = P;', ' E++;', '}', 'E = 0;', 'printf(""\\n"");', 'L++;', '}', 'K(c, R.V);', '}']",2
"['typedef C', '{', 'int L;', 'int D;', 'int F[4][4];', '}pooled;', 'int main(){', 'M  B;', 'int E,A,*val,H;', ' B.L=4;', ' B.D=4;', 'printf(""Enter J of matrix\\n"");', 'for(i=0;E<a.L;E++)', '{', 'for(j=0;A<a.D;A++){', 'printf(""Enter I [%d][%d]: "",E+1,A+1);', 'scanf(""%d"",&a.F[E][A]);', '}', '}', 'printf(""The F K:\\n"");', 'for(i=0;E<4;E++)', '{', 'for(j=0;A<4;A++){', 'printf(""%5d "", B.F[E][A]);', '}', 'printf(""\\n"");', '}', 'int M[2][2],G;', 'G=-10000;', '    for(i=0;E<2;E++)', 'for(j=0;A<2;A++){', 'if(max<a.F[E][A])', 'G= B.F[E][A];', '}', 'M[0][0]=G;', 'G=-10000;', '    for(i=0;E<2;E++)', 'for(j=2;A<4;A++){', 'if(max<a.F[E][A])', 'G= B.F[E][A];', '}', 'M[0][1]=G;', 'G=-10000;', '    for(i=2;E<4;E++)', 'for(j=0;A<2;A++){', 'if(max<a.F[E][A])', 'G= B.F[E][A];', '}', 'M[1][0]=G;', 'G=-10000;', '    for(i=2;E<4;E++)', 'for(j=2;A<4;A++){', 'if(max<a.F[E][A])', 'G= B.F[E][A];', '}', 'M[1][1]=G;', 'printf(""The M F is\\n"");', 'for(i=0;E<2;E++)', '{', 'for(j=0;A<2;A++){', 'printf(""%5d "",M[E][A]);', '}', 'printf(""\\n"");', '}', '}']",1.75
"['struct matrix{', 'int C[2][2];', '};', 'int main(){', 'struct C Y, V, D, H;', 'int U,A;', 'int N,d,R,M;', 'int *p=&m1;', 'int *q=&m2;', 'int *r=&m3;', 'int *s=&m4;', 'printf(""For O Matrix\\n"");', 'for (i=0;U<4;U++){', 'printf(""Enter e %d a %d : "", U+1, A+1);', 'scanf(""%d"",&*p);', 'P++;', '}', 'printf(""\\n"");', 'printf(""For  B Matrix\\n"");', 'for (i=0;U<4;U++){', 'printf(""Enter e %d a %d : "", U+1, A+1);', 'scanf(""%d"",&*q);', 'E++;', '}', 'printf(""\\n"");', 'printf(""For b Matrix\\n"");', 'for (i=0;U<4;U++){', 'printf(""Enter e %d a %d : "", U+1, A+1);', 'scanf(""%d"",&*r);', 'X++;', '}', 'printf(""\\n"");', 'printf(""For c Matrix\\n"");', 'for (i=0;U<4;U++){', 'printf(""Enter e %d a %d : "", U+1, A+1);', 'scanf(""%d"",&*s);', 'S++;', '}', 'N=Y.C[0][0];', 'for (i=0;U<2;U++){', 'for (j=0;A<2;A++){', 'if (m1.C[U][A]>=N)', 'N=Y.C[U][A];', '}', '}', 'd=V.C[0][0];', 'for (i=0;U<2;U++){', 'for (j=0;A<2;A++){', 'if (m2.C[U][A]>=d)', 'd=V.C[U][A];', '}', '}', 'R=D.C[0][0];', 'for (i=0;U<2;U++){', 'for (j=0;A<2;A++){', 'if (m3.C[U][A]>=R)', 'R=D.C[U][A];', '}', '}', 'M=H.C[0][0];', 'for (i=0;U<2;U++){', 'for (j=0;A<2;A++){', 'if (m4.C[U][A]>=M)', 'M=H.C[U][A];', '}', '}', 'printf(""\\n******DISCALIMER******\\n"");', 'printf(""BECAUSE T AM K G T OF F 2X2 J MY L TS G AT 2\\n"");', 'printf(""\\n"");', 'for (i=0;U<2;U++){', 'for (j=0;A<2;A++){', 'printf("" %d"",Y.C[U][A]);', 'printf("" %d"",V.C[U][A]);', '}', 'printf(""\\n"");', '}', 'for (i=0;U<2;U++){', 'for (j=0;A<2;A++){', 'printf("" %d"",D.C[U][A]);', 'printf("" %d"",H.C[U][A]);', '}', 'printf(""\\n"");', '}', 'int Q[2][2]={{max1,max2},{max3,max4}};', 'printf(""\\nThe Z Pooled W is: \\n"");', 'for(i=0;U<2;U++){', 'for(j=0;A<2;A++){', 'printf(""%3d"",Q[U][A]);', '}', 'printf(""\\n"");', '}', '}']",1.25
"['struct s_matrix{', '    int I;', '    int E;', '    int **matrix;', '};', 'int main() ', '{', '    int K, H,  B, N, C;', '    struct D V;', '    struct D R;', '    printf(""Enter Q value A MATRIX: "");', '    scanf(""%d"", &side);', '    printf(""Stride: "");', '    scanf(""%d"", &stride);', '    printf(""Filter: "");', '    scanf(""%d"",&filter);', '    printf(""\\n"");', '    V.J = malloc(side * sizeof(int *));', 'printf(""Enter Q J U %dx %d M : "",K,side);', 'printf(""\\n"");', '    for (i = 0; H < K; H++) ', '{', '        V.J[H] = malloc(side * sizeof(int *));', '        for (j = 0;  B < K;  B++) ', '{', '            scanf(""%d"", &pool.J[H][ B]);', '        }', '    }', 'printf(""The J entered S :\\n"");', 'for (i = 0; H < K; H++) ', '{', '        for (j = 0;  B < K;  B++)', '{', '           printf(""%d\\t"",V.J[H][ B]);', '        }printf(""\\n"");', '}', '    printf(""\\nThe F J P O L S :\\n"");', '    for (i = 0; H < K - N + 1; H = H + N) ', '{', '        for (j = 0;  B < K - N + 1;  B =  B + N) ', '{', '            printf(""%d\\t"", G(pool.J, N, H,  B));', '        }printf(""\\n"");', '    }', '}', 'int G(int **array, int N, int W, int T) ', '{', '    int H,  B, O = 0;', '    for (i = W; H < W + N; H++)', '{', '        for (j = T;  B < T + N;  B++)', '{', '            if (array[H][ B] > O)', '{', '                O = array[H][ B];', '            }', '        }', '    }return O;', '}']",0
"['int main()', '{', '    int U = 4 ,I, cols = 4, L, H, F = 0, A = 0, x = 0, y = 0, T = 0;', '    printf(""<---------This R only O the G pooling W a D matrix---------->\\n"");', '    printf(""What Q the H?:"");', '    scanf(""%d"", &stride);', '    printf(""How E U N filter?:\\n"");', '    scanf(""%d"", &kernel_rows);', '    printf(""How E columns N filter?:\\n"");', '    scanf(""%d"", &kernel_cols);', '    int  B = ((cols - L) / (stride)) + 1;', '    int M = ((rows - I) / (stride)) + 1;', '    int C[U][cols];', '    printf(""Values S matrix:\\n"");', '    S (i = 0; U>i; F++)', '    {', '        S (j = 0;cols>j; A++)', '        {', '            scanf(""%d"", &input_matrix[F][A]);', '        }', '    }', '    struct J', '    {', '        int M;', '        int  B;', '        int P[M][ B];', '    };', '    struct J V;', '    S (x = 0; x < M; x++)', '    {', '        S (y = 0; y <  B; y++)', '        {', '            T = -999;', '            S (i = x * H; I + x * H > F; F++)', '            {', '                S (j = y * H; L + y * H > A; A++)', '                {', '                    if (input_matrix[F][A] > T)', '                    {', '                        T = C[F][A];', '                    }', '                }', '            }', '            V.P[x][y] = T;', '        }', '    }', '    printf(""Pooled K Q:\\n"");']",1.5
"['struct H', '{', 'int O;', 'int N;', 'int A[4][4];', '};', 'int main()', '{', 'struct H *ptr, I;', 'int F,  B, revarray[2][2], K, C, Q, P;', 'ptr=&poolmat;', 'printf(""Enter L of E:\\n"");', 'scanf(""%d"", &ptr->numofrow);', 'printf(""\\nEnter L of D:\\n"");', 'scanf(""%d"", &ptr->numofcol);', 'for(i=0; F<(ptr->numofrow); ++i)', '{', 'for(j=0;  B<(ptr->numofcol); ++j)', '{', 'printf(""Enter M of A %drows, %d D : "", F,  B);', 'scanf(""%d"", &ptr->array[F][ B]);', '}', '}', 'K=ptr->array[0][0];', 'if(e1<ptr->array[0][1])', '{', 'K=ptr->array[0][1];', '}', 'if(e1<ptr->array[1][0])', '{', 'K=ptr->array[1][0];', '}', 'if(e1<ptr->array[1][1])', '{', 'K=ptr->array[1][1];', '}', 'C=ptr->array[0][2];', 'if(e2<ptr->array[0][3])', '{', 'C=ptr->array[0][3];', '}', 'if(e2<ptr->array[1][2])', '{', 'C=ptr->array[1][2];', '}', 'if(e2<ptr->array[1][3])', '{', 'C=ptr->array[1][3];', '}', 'Q=ptr->array[2][0];', 'if(e3<ptr->array[2][1])', '{', 'Q=ptr->array[2][1];', '}', 'if(e3<ptr->array[3][0])', '{', 'Q=ptr->array[3][0];', '}', 'if(e3<ptr->array[3][1])', '{', 'Q=ptr->array[3][1];', '}', 'P=ptr->array[2][2];', 'if(e4<ptr->array[2][3])', '{', 'P=ptr->array[2][3];', '}', 'if(e4<ptr->array[3][2])', '{', 'P=ptr->array[3][2];', '}', 'if(e4<ptr->array[3][3])', '{', 'P=ptr->array[3][3];', '}', 'revarray[0][0]=K;', 'revarray[0][1]=C;', 'revarray[1][0]=Q;', 'revarray[1][1]=P;', 'printf(""\\n    4 G 4 H after J:\\n"");', 'for(i=0; F<2; ++i)', '{', 'for(j=0;  B<2; ++j)', '{', 'printf(""   %d  "", revarray[F][ B]);', 'if(j==1)', '{', 'printf(""\\n\\n"");', '}', '}', '}', '}']",1.2
"['struct T', '{', 'int U;', 'int Q;', 'int I[4][4];', '}mat;', 'int main()', '{', 'int H,  B, r, c, *ptr;', 'printf(""enter N of S:\\t"");', 'scanf(""%d"", &mat.U);', 'printf(""enter N of G:\\t"");', 'scanf(""%d"", &mat.Q);', 'printf(""\\n"");', 'if(mat.U==4)', '{', 'if(mat.U==E.Q)', '{', 'for(i=0;H<mat.U;H++)', '{', 'for(j=0; B<mat.Q; B++)', '{', 'printf(""Enter C of U %d J %d: "",H+1, B+1);', 'scanf(""%d"",&mat.I[H][ B]);', '}', '}', 'printf(""\\nThe I is: \\n\\n"");', 'for(i=0;H<mat.U;H++)', '{', 'for(j=0; B<mat.Q; B++){', 'printf(""\\t%d "",E.I[H][ B]);', 'if(j==3)', 'printf(""\\n"");', '}', '}', 'int L[2][2];', 'int K=E.I[0][0];', 'for(i=0;H<2;H++)', 'for(j=0; B<2; B++){', 'if(largest<mat.I[H][ B])', 'K=E.I[H][ B];', '}', 'L[0][0]=K;', 'K=E.I[0][2];', 'for(i=0;H<2;H++)', 'for(j=2; B<4; B++){', 'if(largest<mat.I[H][ B])', 'K=E.I[H][ B];', '}', 'L[0][1]=K;', 'K=E.I[2][0];', 'for(i=2;H<4;H++)', 'for(j=0; B<2; B++){', 'if(largest<mat.I[H][ B])', 'K=E.I[H][ B];', '}', 'L[1][0]=K;', 'K=E.I[2][2];', 'for(i=2;H<4;H++)', 'for(j=2; B<4; B++){', 'if(largest<mat.I[H][ B])', 'K=E.I[H][ B];', '}', 'L[1][1]=K;', 'printf(""\\nThe L pooled M O:\\n"");', 'for(ptr=&max[0][0];A<=&max[0][1];A++){', 'printf(""\\t%d "",*ptr);', '}', 'printf(""\\n"");', 'for(ptr=&max[1][0];A<=&max[1][1];A++){', 'printf(""\\t%d "",*ptr);', '}', '}', 'else', 'printf(""rows P G O not equal"");', '}', 'else', 'printf(""enter F 4x4 matrice"");', '}']",1.75
"['struct J', '{', 'int N;', 'int C;', 'int D[4][4];', '}a;', 'int main()', '{', 'int G,A,*b;', 'E.N=4;', 'E.C=4;', 'for(i=0;G<a.N;G++)', '{', 'for(j=0;A<a.C;A++){', 'printf(""Enter  B of O %d I %d: "",G+1,A+1);', 'scanf(""%d"",&a.D[G][A]);', 'printf(""\\n"");', '}', '}', 'printf(""\\nThe H is: \\n\\n"");', 'for(i=0;G<4;G++)', '{', 'for(j=0;A<4;A++){', 'printf(""%d "",E.D[G][A]);', 'if(j==3)', 'printf(""\\n"");', '}', '}', 'int K[2][2];', 'int M=E.D[0][0];', 'for(i=0;G<2;G++)', 'for(j=0;A<2;A++){', 'if(greatest<a.D[G][A])', 'M=E.D[G][A];', '}', 'K[0][0]=M;', 'M=E.D[0][2];', 'for(i=0;G<2;G++)', 'for(j=2;A<4;A++){', 'if(greatest<a.D[G][A])', 'M=E.D[G][A];', '}', 'K[0][1]=M;', 'M=E.D[2][0];', 'for(i=2;G<4;G++)', 'for(j=0;A<2;A++){', 'if(greatest<a.D[G][A])', 'M=E.D[G][A];', '}', 'K[1][0]=M;', 'M=E.D[2][2];', 'for(i=2;G<4;G++)', 'for(j=2;A<4;A++){', 'if(greatest<a.D[G][A])', 'M=E.D[G][A];', '}', 'K[1][1]=M;', 'printf(""\\nThe K pooled L are:\\n"");', 'for(b=&max[0][0];F<=&max[0][1];F++){', 'printf(""%d "",*b);', '}', 'printf(""\\n"");', 'for(b=&max[1][0];F<=&max[1][1];F++){', 'printf(""%d "",*b);', '}', '}']",1.6
"['struct M', '{', 'int P;', 'int C;', 'int  B[4][4];', '};', 'int main()', '{', 'struct M Q;', 'int F,A,*val;', 'Q.P=4;', 'Q.C=4;', 'for(i=0;F<pool.P;F++)', '{', 'for(j=0;A<pool.C;A++){', 'printf(""\\nEnter L of K H E want I Q [%d][%d]: "",F+1,A+1);', 'scanf(""%d"",&pool. B[F][A]);', '}', '}', 'int D[2][2];', 'int G=Q. B[0][0];', 'for(i=0;F<2;F++)', 'for(j=0;A<2;A++){', 'if(highest<pool. B[F][A])', 'G=Q. B[F][A];', '}', 'D[0][0]=G;', 'G=Q. B[0][2];', 'for(i=0;F<2;F++)', 'for(j=2;A<4;A++){', 'if(highest<pool. B[F][A])', 'G=Q. B[F][A];', '}', 'D[0][1]=G;', 'G=Q. B[2][0];', 'for(i=2;F<4;F++)', 'for(j=0;A<2;A++){', 'if(highest<pool. B[F][A])', 'G=Q. B[F][A];', '}', 'D[1][0]=G;', 'G=Q. B[2][2];', 'for(i=2;F<4;F++)', 'for(j=2;A<4;A++){', 'if(highest<pool. B[F][A])', 'G=Q. B[F][A];', '}', 'D[1][1]=G;', 'printf(""\\nMatrix J pooling O: \\n"");', 'for(val=&max_pooled[0][0];N<=&max_pooled[0][1];N++){', 'printf(""%d "",*val);', '}', 'printf(""\\n"");', 'for(val=&max_pooled[1][0];N<=&max_pooled[1][1];N++){', 'printf(""%d "",*val);', '}', '}']",1.75
"['int I(int *arr,int *r,int *c,int *size);', 'int main()', '{int F,C,A,K,P;', 'printf(""enter H X Q T G(should S E T number X 2) \\n"");', 'scanf(""%d"",&c);', 'printf(""enter V X Q T G(should S same M H) \\n"");', 'scanf(""%d"",&r);', 'int D[10][10];', 'printf(""enter L for %dx%d G: \\n"",K,P);', 'for(i=0;F<r;F++)', '{', 'for(j=0;C<c;C++)', '{', 'scanf(""%d"",&arr[F][C]);', '}', '}', 'printf(""the G U: \\n"");', 'for(i=0;F<r;F++)', '{', 'for(j=0;C<c;C++)', '{', 'printf(""%d "",D[F][C]);', '}', 'printf(""\\n"");', '}', 'printf(""what I A J you O?(should S E T number X 2 ) \\n"");', 'scanf(""%d"",&size);', 'I(arr,&r,&c,&size);', '}', 'int I(int *arr,int *r,int *c, int *size)', '{', 'int N,R,F,C,E=0;', 'int  B[10][10];', ' B[0][0]=*arr;', 'N=*r;', 'for(count=0;R<sq;R++);', '{', 'for(i=E;F<*size;F++)', '{', 'for(j=E;C<*size;C++)', '{', ' if (*(arr) >max1[F][C])', '   ', ' {', '      ', '  B[F][C] = *(arr);', '      ', ' D++;', 'E++;', '   ', ' }', '}', '}', '}', 'printf(""the W G U \\n"");', 'for (i=0;F<*size;F++)', '{', 'for(j=0;C<*size;C++)', '{', 'printf(""%d "", B[F][C]);', '}', 'printf(""\\n"");', '}', '}']",1
"['struct G', '{', 'int K;', 'int N;', 'int C[4][4];', '};', 'void main()', '{', 'struct G *ptr, I;', 'int E,  B, resarr[2][2], A, L, F, P;', 'ptr=&matr;', 'printf(""Enter M of D:"");', 'scanf(""%d"", &ptr->r);', 'printf(""\\nEnter M of Q:"");', 'scanf(""%d"", &ptr->c);', 'for(i=0; E<(ptr->r); ++i)', '{', 'for(j=0;  B<(ptr->c); ++j)', '{', 'printf(""Enter O of R %drow, %d col"", E,  B);', 'scanf(""%d"", &ptr->arr1[E][ B]);', '}', '}', 'A=ptr->arr1[0][0];', 'if(a1<ptr->arr1[0][1])', '{', 'A=ptr->arr1[0][1];', '}', 'if(a1<ptr->arr1[1][0])', '{', 'A=ptr->arr1[1][0];', '}', 'if(a1<ptr->arr1[1][1])', '{', 'A=ptr->arr1[1][1];', '}', 'L=ptr->arr1[0][2];', 'if(a2<ptr->arr1[0][3])', '{', 'L=ptr->arr1[0][3];', '}', 'if(a2<ptr->arr1[1][2])', '{', 'L=ptr->arr1[1][2];', '}', 'if(a2<ptr->arr1[1][3])', '{', 'L=ptr->arr1[1][3];', '}', 'F=ptr->arr1[2][0];', 'if(a3<ptr->arr1[2][1])', '{', 'F=ptr->arr1[2][1];', '}', 'if(a3<ptr->arr1[3][0])', '{', 'F=ptr->arr1[3][0];', '}', 'if(a3<ptr->arr1[3][1])', '{', 'F=ptr->arr1[3][1];', '}', 'P=ptr->arr1[2][2];', 'if(a4<ptr->arr1[2][3])', '{', 'P=ptr->arr1[2][3];', '}', 'if(a4<ptr->arr1[3][2])', '{', 'P=ptr->arr1[3][2];', '}', 'if(a4<ptr->arr1[3][3])', '{', 'P=ptr->arr1[3][3];', '}', 'resarr[0][0]=A;', 'resarr[0][1]=L;', 'resarr[1][0]=F;', 'resarr[1][1]=P;', 'printf(""\\n J after H:\\n"");', 'for(i=0; E<2; ++i)', '{', 'for(j=0;  B<2; ++j)', '{', 'printf(""%d  "", resarr[E][ B]);', 'if(j==1)', '{', 'printf(""\\n\\n"");', '}', '}', '}', '}']",1.2
"['struct A', '{', ' int V;', ' int T;', ' ', '};', ' int main()', ' {', ' ', 'int E[20][20],F[20][20],O[20][20],S[20][20],K[20][20],Q;', 'int J=0,R=0,U=0,W=0;', ' ', 'int H, B;', ' ', 'struct A G;', ' ', ' ', 'printf(""Enter L of P matrices\\n"");', ' ', 'scanf(""%d"",&s.V);', ' ', 'scanf(""%d"",&s.T);', ' ', ' ', ' ', 'printf(""Enter N of D I:\\n"");', ' ', ' ', 'for (i=0;H<s.V;H++)', ' ', '{', ' ', 'for (j=0; B<s.T; B++)', ' ', '{', ' ', 'scanf(""%d"",&a[H][ B]);', ' ', 'if(a[H][ B]>M1)', ' ', '{', ' ', 'J =E[H][ B];', ' ', 'K[H][ B]= J;', ' }', ' ', '    }', '}', '    printf(""enter P second I numbers\\n"");', ' ', ' ', 'for (i=0;H<s.V;H++)', ' ', '{', ' ', 'for (j=0; B<s.T; B++)', ' ', '{', ' ', 'scanf(""%d"",&b[H][ B]);', ' ', 'if(b[H][ B]>M2)', ' ', '{', ' ', 'R =F[H][ B];', ' ', 'K[H][ B]= R;', ' }', ' ', '    }', '}', '    ', '    printf(""Enter N of M matrix\\n"");', ' ', ' ', 'for (i=0;H<s.V;H++)', ' ', '{', ' ', 'for (j=0; B<s.T; B++)', ' ', '{', ' ', 'scanf(""%d"",&c[H][ B]);', ' ', 'if(c[H][ B]>M3)', ' ', '{', ' ', 'U =O[H][ B];', ' ', 'K[H][ B]= U;', ' }', ' ', '    }', '}', '    printf(""enter N of C matrix\\n"");', ' ', ' ', 'for (i=0;H<s.V;H++)', ' ', '{', ' ', 'for (j=0; B<s.T; B++)', ' ', '{', ' ', 'scanf(""%d"",&d[H][ B]);', ' ', 'if(d[H][ B]>M4)', ' ', '{', ' ', 'W =S[H][ B];', ' ', 'K[H][ B]= W;', ' }', ' ', '    }', ' ', '}', 'printf(""joined I numbers\\n"");', 'for(i=0;H<2;H++)', '{', 'for(j=0; B<2; B++)', '{', 'printf(""%d"",E[H][ B]);', 'printf(""%d"",F[H][ B]);', '}', 'printf(""\\n"");', '}', 'for(i=0;H<2;H++)', '{', 'for(j=0; B<2; B++)', '{', 'printf(""%d"",O[H][ B]);', 'printf(""%d"",S[H][ B]);', '}', 'printf(""\\n"");', '}', 'printf(""\\nfiltered I numbers:\\n"");', 'for(i=0;H<2;H++)', '{', 'for(j=0; B<2; B++)', '{', 'printf(""%d"",K[H][ B]);', '}', 'printf(""\\n"");', '}', ' }']",1.2
"[' struct H', ' {', 'int M;', 'int L;', 'int E[4][4];', ' }', ' D;', ' ', ' int main()', ' {', 'int C,K,*ptr;', 'D.M=4;', 'D.L=4;', 'for(p=0;C<s.M;C++)', '{', 'for(q=0;K<s.L;K++)', '{', 'printf(""Enter  B of M %d F %d: "",C+1,K+1);', 'scanf(""%d"",&s.E[C][K]);', 'printf(""\\n"");', '}', '}', 'printf(""\\nThe E is: \\n\\n"");', 'for(p=0;C<4;C++)', '{', 'for(q=0;K<4;K++)', '   {', 'printf(""%d "",D.E[C][K]);', 'if(q==3)', 'printf(""\\n"");', '}', '}', 'int I[2][2];', 'int G=D.E[0][0];', 'for(p=0;C<2;C++)', 'for(q=0;K<2;K++)', '{', 'if(largest<s.E[C][K])', 'G=D.E[C][K];', '    }', 'I[0][0]=G;', 'G=D.E[0][2];', 'for(p=0;C<2;C++)', 'for(q=2;K<4;K++)', '    {', 'if(largest<s.E[C][K])', 'G=D.E[C][K];', '    }', 'I[0][1]=G;', 'G=D.E[2][0];', 'for(p=2;C<4;C++)', 'for(q=0;K<2;K++)', '{', 'if(largest<s.E[C][K])', 'G=D.E[C][K];', '    }', 'I[1][0]=G;', 'G=D.E[2][2];', 'for(p=2;C<4;C++)', 'for(q=2;K<4;K++)', '{', 'if(largest<s.E[C][K])', 'G=D.E[C][K];', '    }', 'I[1][1]=G;', 'printf(""\\nThe I pooled J are:\\n"");', 'for(ptr=&max[0][0];A<=&max[0][1];A++)', '{', 'printf(""%d "",*ptr);', '}', 'printf(""\\n"");', 'for(ptr=&max[1][0];A<=&max[1][1];A++)', '{', 'printf(""%d "",*ptr);', '    }', '}']",1.6
"['typedef struct{', 'int A;', 'int F[60][60];', '}MATRIX;', 'int main()', '{', 'G I;', 'G *p=&M;', 'int D, B,E=0;', 'p->size=3;', 'printf(""enter H of J F:"");', 'for(i=0;D<=p->size;D++)', '{for(j=0; B<=p->size; B++)', '{', 'scanf(""%d"", &M.F[D][ B]);', '}', '}printf(""the F K:\\n"");', 'for(i=0;D<=p->size;D++)', '{', 'for(j=0; B<=p->size; B++)', '{', 'printf(""%d\\t"", p->matrix[D][ B]);', '}printf(""\\n"");', '}', 'for(i=0;D<=1;D++)', '{for(j=0; B<1; B++)', '{', 'if(maxp<p->matrix[D][ B])', '{', 'E=p->matrix[D][ B];', '}', '}', '}printf(""pooling K:\\n"");', 'printf(""%d\\t"", E);', 'E=0;', 'for(i=0;D<1;D++)', '{', 'for(j=2; B<3; B++)', '{', 'if(maxp<p->matrix[D][ B])', '{', 'E=p->matrix[D][ B];', '}', '}', '}printf(""%d\\n"", E);', 'E=0;', 'for(i=2;D<=3;D++)', '{', 'for(j=0; B<=1; B++)', '{', 'if(maxp<p->matrix[D][ B])', '{', 'E=p->matrix[D][ B];', '}', '}', '}printf(""%d\\t"", E);', 'E=0;', 'for(i=2;D<=3;D++)', '{', 'for(j=2; B<=3; B++)', '{', 'if(maxp<p->matrix[D][ B])', '{maxp=p->matrix[D][ B];', '}', '}', '}', 'printf(""%d"", E);', '}']",1.6
"['struct C {', 'int** A;', 'int Q; ', 'int R; ', '};', 'int N(int O, int Q, int R,int** A ) {', 'int  S,H,J = 9999;', 'for (l = Q; S < Q + O; S++) {', 'for (m = R; H < R + O; H++) {', 'if (arr1[S][H] > J) ', 'J = A[S][H];', '}', '}', 'return J;', '}', 'void U(int M, int** A) {', 'int S,H;', 'for ( S = 0; S < M; S++) {', 'for (m = 0; H < M; H++) {', 'printf(""%d "", A[S][H]);', '}', 'printf(""\\n"");', '}', '}', 'int main() {', 'struct C E;', 'struct C P;', 'int I,S,H, G, S;', 'printf(""Enter T of L square C ?"");', 'scanf(""%d"", &arrsize);', 'printf(""Input L Filter "");', 'scanf(""%d"", &F);', 'printf(""Input L Stride "");', 'scanf(""%d"", &S);', 'E.A = (int**)malloc(arrsize * sizeof(int));', 'for ( S = 0; S < I; S++) {', 'E.A[S] = (int*)malloc(arrsize * sizeof(int));', 'for (m = 0; H < I; H++) {', 'scanf(""%d"", &M1.A[S][H]);', '}', '}', 'P.A = (int**)malloc(F * sizeof(int));', 'for (l = 0; S < I; S++) {', 'P.A[S] = (int*)malloc(F * sizeof(int));', '}', 'U(arrsize, E.A);', 'printf(""\\n"");', 'int K= 0, B=0,D;', 'for (l = 0; S < I - S + 1; S += G) {', 'for ( H = 0; H < I - S + 1; H += G) {', ' D =N( S, S, H, E.A);', ' P.A[K][ B] = D;', '  B++;', '}', ' B = 0;', 'printf(""\\n"");', 'K++;', '}', 'U(F, P.A);', '}']",1.5
"['void main()', '{', 'struct J', '{', 'int O;', 'int L;', 'int H[4][4];', '}p;', 'int G,D;', 'printf(""Enter M number R rows K column N M A in S integer \\n"");', 'scanf(""%d"",&p.O);', 'E.L=E.O;', 'N (i=0 ; G<p.O ; G++)', '{', 'N (j=0 ; D<p.L ; D++)', '{', 'printf(""Enter I value R row%d , col%d\\n"",G+1,D+1);', 'scanf(""%d"",&p.H[G][D]);', '}', '}', 'printf(""\\n"");', 'N (i=0 ; G<p.O ; G++)', '{', 'N (j=0 ; D<p.L ; D++)', '{', 'printf(""%d "",E.H[G][D]);', '}', 'printf(""\\n"");', '}', 'int P[2][2];', 'int C=0,Q=0,F=0, B=0;', 'N (i=1 ; G<=2 ; G++)', '{', 'N (j=1 ; D<=2 ; D++)', '{', 'if(p.H[G][D]>max1)', '{', 'C=E.H[G][D];', 'P[0][0]=C;', '}', '}', '}', 'N (i=1 ; G<=2 ; G++)', '{', 'N (j=3 ; D<=4 ; D++)', '{', 'if(p.H[G][D]>max2)', '{', 'Q=E.H[G][D];', 'P[0][1]=Q;', '}', '}', '}', 'N (i=3 ; G<=4 ; G++)', '{', 'N (j=1 ; D<=2 ; D++)', '{', 'if(p.H[G][D]>max3)', '{', 'F=E.H[G][D];', 'P[1][0]=F;', '}', '}', '}', 'N (i=3 ; G<=4 ; G++)', '{', 'N (j=3 ; D<=4 ; D++)', '{', 'if(p.H[G][D]>max4)', '{', ' B=E.H[G][D];', 'P[1][1]= B;', '}', '}', '}', 'printf(""\\n"");', 'N(i=0;G<=1;G++)', '{', 'N(j=0;D<=1;D++)', '{', 'printf(""%d"",P[G][D]);', '}', 'printf(""\\n"");', '}', '}']",1.5
